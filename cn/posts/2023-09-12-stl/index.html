<a name=top></a><!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>余忻萌 / Sandy's blog</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/r.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/bash.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/python.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/vega@5.17.0></script>
<script src=https://cdn.jsdelivr.net/npm/vega-lite@4.17.0></script>
<script src=https://cdn.jsdelivr.net/npm/vega-embed@6.12.2></script>
<script>hljs.initHighlightingOnLoad()</script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script></head><body><div class=wrapper><header class=header><nav class=nav><a href=/ class=nav-logo><img src=/media/dog-logo.jpg width=50 height=50 alt=Hugo-ht></a><ul class=nav-links><ul class=nav-links><li><a href=/>Home</a></li><li><a href=/en/about/>About me</a></li><li><a href=/en/posts/>English</a></li><li><a href=/cn/posts/>Chinese</a></li></ul></ul></nav></header><main class=content role=main><div style=text-align:center><h1>算法与数据结构：C++中的STL</h1><p>余忻萌
/ 2023-09-12</p><hr></div><span class=article-toolbar></span><div class="body-text list-text"><p>写一个c++常用的stl容器和库函数的笔记，方便之后忘记一些用法细节的时候查。</p><h2 id=vector>vector<a href=#vector class=header-anchor arialabel=Anchor> #</a></h2><ul><li>变长数组，倍增的思想</li><li>size() 返回元素个数</li><li>empty() 返回是否为空</li><li>clear() 清空</li><li>front()/back()</li><li>push_back()/pop_back()</li><li>begin()/end()</li><li>front()/back()</li><li><input disabled type=checkbox></li><li>支持比较运算，按字典序</li></ul><h3 id=举例说明一些常用操作>举例说明一些常用操作<a href=#举例说明一些常用操作 class=header-anchor arialabel=Anchor> #</a></h3><ul><li>构造函数：
vectora(10) //10个元素
vectora(10,1) //10个元素，都为1
vector a(b); || a=b;//用b向量来创建a向量，整体复制性赋值</li><li>a.erase(a.begin()+1,a.begin()+3); //删除的元素从a.begin()+1算起（包括它）一直到a.begin()+3（不包括它）</li><li>a.insert(a.begin()+1,5); //在a的第1个元素（从第0个算起）的位置插入数值5，如a为1,2,3,4，插入元素后为1,5,2,3,4</li><li>a.insert(a.begin()+1,3,5); //在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5</li><li>a.insert(a.begin()+1,b+3,b+6); //b为数组，在a的第1个元素（从第0个算起）的位置插入b的第3个元素到第5个元素（不包括b+6）</li><li>a==b; //b为向量，向量的比较操作还有!=,>=,&lt;=,>,&lt;</li><li>a.swap(b); //b为向量，将a中的元素和b中的元素进行整体性交换</li><li>a.resize(10); //将a的现有元素个数调至10个，多则删，少则补，其值随机</li><li>a.resize(10,2); //将a的现有元素个数调至10个，多则删，少则补，其值为2</li></ul><h3 id=几种重要的算法>几种重要的算法<a href=#几种重要的算法 class=header-anchor arialabel=Anchor> #</a></h3><pre><code>头文件 #include&lt;algorithm&gt;
- sort(a.begin(),a.end()); //默认从小到大
- reverse(a.begin(),a.end());
- copy(a.begin(),a.end(),b.begin()+1); //把a中的从a.begin()（包括它）到a.end()（不包括它）的元素复制到b中，从b.begin()+1的位置（包括它）开始复制，覆盖掉原有元素
- find(a.begin(),a.end(),10); //在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，若存在返回其在向量中的位置
</code></pre><h3 id=一些误区>一些误区<a href=#一些误区 class=header-anchor arialabel=Anchor> #</a></h3><pre tabindex=0><code> vector&lt;int&gt; a;
 for(int i=0;i&lt;10;i++)
     a[i]=i;
</code></pre><p>//这种做法以及类似的做法都是错误的。下标只能用于获取已存在的元素，而现在的a[i]还是空的对象
在操作双重数组的时候得多留意，老犯这种错</p><pre tabindex=0><code>vector&lt;vector&lt;int&gt;&gt; temp;
for(int i=0;i&lt;m;i++){
  vector&lt;int&gt;tt(n);
  temp.push_back(tt);
}
or
vector&lt;vector&lt;int&gt;&gt; temp(m,vector&lt;int&gt;(n));
</code></pre><h2 id=pair>pair<a href=#pair class=header-anchor arialabel=Anchor> #</a></h2><ul><li>可以打包放入map</li><li>.first</li><li>.second</li><li>支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</li><li>sort排序的话默认从小到大，先第一关键字，再第二关键字</li></ul><h2 id=string>string<a href=#string class=header-anchor arialabel=Anchor> #</a></h2><ul><li><p>size()/length() 返回字符串长度/字符个数（不包括\0）</p></li><li><p>empty()</p></li><li><p>clear()</p></li><li><p>substr(起始下标，(子串长度)) 返回子串</p></li><li><p>c_str() 返回字符串所在字符数组的起始地址</p></li><li><p>front()/back() // front访问string中第一个字符，back访问string中最后一个字符</p></li><li><p>append/+=</p></li><li><p>push_back()/pop_back()</p></li><li><p>insert()</p></li><li><p>erase()</p></li><li><p>find() //一个字符串中寻找某个字符或字符串.若存在，返回其起始位置;不存在，返回的是npos（是一个表示位置的整数） size_t find (const string& str, size_t pos = 0) const;</p></li><li><p>rfind() //从后往前寻找 size_t rfind (const string& str, size_t pos = npos) const;</p></li><li><p>swap</p></li><li><p>迭代器，实际为指针
begin/end //指向开头和结尾的&rsquo;\0'
rend/rbegin //指向开头前面和结尾&rsquo;\0&rsquo;前面</p></li></ul><h3 id=举例说明一些常用操作-1>举例说明一些常用操作<a href=#举例说明一些常用操作-1 class=header-anchor arialabel=Anchor> #</a></h3><ul><li>构造函数：</li><li>string s2(s1); //通过字符串常量初始化</li><li>string s3(s4, 5, 5); //通过字符串子串初始化 string (const string& str, size_t pos, size_t len = npos);pos为子串的位置，len拷贝的长度，若len大于从子串pos位置开始后面字符总数，则表示初始化到子串结尾即可</li><li>string s5(&ldquo;hello wrold&rdquo;, 6); //通过字符串前n个字符初始化</li><li>string s6(10, &lsquo;x&rsquo;); //用n个字符c初始化字符串</li><li>char[]直接可以用string接收</li><li>一些输入输出sscanf等string要转char[]: str.c_str()</li><li>getline函数， 从用户输入中获取一行数据，这也就意味着，当我们我们从用户输入数据中，遇到了空格，我们也会获取空格字符，直到遇到\n为止，这也就是此函数与流插入（&#187;）最大的区别</li></ul><h2 id=queue>queue<a href=#queue class=header-anchor arialabel=Anchor> #</a></h2><ul><li>size()</li><li>empty()</li><li>push() 向队尾插入一个元素</li><li>front() 返回队头元素</li><li>back() 返回队尾元素</li><li>pop() 弹出队头元素</li></ul><h2 id=priority_queue>priority_queue<a href=#priority_queue class=header-anchor arialabel=Anchor> #</a></h2><ul><li>优先队列，默认是大根堆</li><li>size()</li><li>empty()</li><li>push() 插入一个元素</li><li>top() 返回堆顶元素</li><li>pop() 弹出堆顶元素</li><li>定义成小根堆的方式：priority_queue&lt;int, vector, greater> q;</li></ul><h2 id=stack>stack<a href=#stack class=header-anchor arialabel=Anchor> #</a></h2><ul><li>size()</li><li>empty()</li><li>push() 向栈顶插入一个元素</li><li>top() 返回栈顶元素</li><li>pop() 弹出栈顶元素</li></ul><h2 id=deque>deque<a href=#deque class=header-anchor arialabel=Anchor> #</a></h2><ul><li>双端队列</li><li>size()</li><li>empty()</li><li>clear()</li><li>front()/back()</li><li>push_back()/pop_back()</li><li>push_front()/pop_front()</li><li>begin()/end()</li><li>[]</li></ul><h2 id=set-map-multiset-multimap>set, map, multiset, multimap<a href=#set-map-multiset-multimap class=header-anchor arialabel=Anchor> #</a></h2><ul><li>基于平衡二叉树（红黑树），动态维护有序序列</li><li>size()</li><li>empty()</li><li>clear()</li><li>begin()/end()</li><li>++, &ndash; 返回前驱和后继，时间复杂度 O(logn)</li></ul><h4 id=setmultiset>set/multiset<a href=#setmultiset class=header-anchor arialabel=Anchor> #</a></h4><ul><li>insert() 插入一个数</li><li>find() 查找一个数</li><li>count() 返回某一个数的个数</li><li>erase()
(1) 输入是一个数x，删除所有x O(k + logn)
(2) 输入一个迭代器，删除这个迭代器</li><li>lower_bound()/upper_bound()
(1) lower_bound(x) 返回大于等于x的最小的数的迭代器
(2) upper_bound(x) 返回大于x的最小的数的迭代器</li></ul><h4 id=mapmultimap>map/multimap<a href=#mapmultimap class=header-anchor arialabel=Anchor> #</a></h4><ul><li>insert() 插入的数是一个pair</li><li>erase() 输入的参数是pair或者迭代器</li><li>find()</li><li>[] 注意multimap不支持此操作。 时间复杂度是 O(logn)</li><li>lower_bound()/upper_bound()</li></ul><h4 id=unordered_set-unordered_map-unordered_multiset-unordered_multimap-哈希表>unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表<a href=#unordered_set-unordered_map-unordered_multiset-unordered_multimap-哈希表 class=header-anchor arialabel=Anchor> #</a></h4><ul><li>和上面类似，增删改查的时间复杂度是 O(1)</li><li>不支持 lower_bound()/upper_bound()， 迭代器的++，&ndash;</li></ul><h2 id=sort>sort<a href=#sort class=header-anchor arialabel=Anchor> #</a></h2><h2 id=sscanf--sprintf>sscanf & sprintf<a href=#sscanf--sprintf class=header-anchor arialabel=Anchor> #</a></h2><h2 id=heading><a href=#heading class=header-anchor arialabel=Anchor>#</a></h2><p style=color:#777>最后更新于： 2023-09-12</p></div><a href=#top><i class="fa fa-chevron-up" style=font-size:30px;color:#000></i></a><div>☝ 返回顶部</div></main><footer class=footer><script src=https://utteranc.es/client.js repo=Wooooov/Wooooov.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script><script type=text/javascript src=/js/math-code.js></script>
<script async src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type=text/javascript src=/js/center-img.js></script><ul class=footer-links><li><a href=https://gohugo.io/ class=footer-links-kudos target=_blank>Made with <img src=/media/hugo-logo.png width=22 height=22></a></li><li><a href=https://github.com/Wooooov class=footer-links-kudos target=_blank>Content in
<i class="fa fa-github" style=font-size:24px></i></a></li></ul><div class=copyright-text>©
Sandy
2023-2023</div></footer><div style=text-align:center;color:gray;margin-top:-20px;font-size:19px;margin-bottom:10px><br><span id=busuanzi_container_site_pv>--- Website visits: <span id=busuanzi_value_site_pv></span> times. ---</span></br></div>